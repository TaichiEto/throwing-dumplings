<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>È§ÉÂ≠êÊäï„ÅíÊ§úÂÆöË©¶È®ì | Gyoza Throwing Master</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Yuji+Syuku&display=swap');
        
        body {
            font-family: 'Yuji Syuku', serif;
            touch-action: none; /* Prevent zooming/scrolling on mobile */
            background-color: #8B0000; /* Deep Red */
            overflow: hidden;
        }
        
        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: repeating-linear-gradient(
                45deg,
                #fdfbf7,
                #fdfbf7 20px,
                #f5f5f5 20px,
                #f5f5f5 40px
            );
            overflow: hidden;
        }

        /* UI Layers */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .interactive {
            pointer-events: auto;
        }

        .retro-box {
            background: #D32F2F;
            border: 4px solid #FBC02D;
            color: white;
            padding: clamp(10px, 3vw, 20px);
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            max-width: 90%;
        }

        .retro-box h1, .retro-box h2, .retro-box h3 {
            font-size: clamp(1.5rem, 6vw, 2.5rem);
            margin-bottom: 0.5rem;
        }

        .retro-box p {
            font-size: clamp(0.8rem, 3vw, 1.2rem);
        }

        .retro-box .text-4xl {
            font-size: clamp(1.8rem, 7vw, 2.5rem) !important;
        }

        .retro-box .text-5xl {
            font-size: clamp(2rem, 8vw, 3rem) !important;
        }

        .retro-box .text-3xl {
            font-size: clamp(1.5rem, 6vw, 2rem) !important;
        }

        .retro-box .text-xl {
            font-size: clamp(1rem, 4vw, 1.5rem) !important;
        }

        .retro-box .text-2xl {
            font-size: clamp(1.2rem, 5vw, 1.8rem) !important;
        }

        .btn {
            background: #FBC02D;
            color: #8B0000;
            border: none;
            padding: clamp(8px, 2vw, 10px) clamp(20px, 5vw, 30px);
            font-size: clamp(1rem, 4vw, 1.2rem);
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.1s;
            margin-top: 10px;
            box-shadow: 0 4px 0 #C49000;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #C49000;
        }

        @media (max-width: 768px) {
            .btn {
                padding: clamp(6px, 1.5vw, 8px) clamp(15px, 4vw, 20px);
                font-size: clamp(0.9rem, 3.5vw, 1rem);
            }
        }

        .hud {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
            font-size: clamp(0.8rem, 3vw, 1.5rem);
            color: #D32F2F;
            font-weight: bold;
            pointer-events: none;
            text-shadow: 2px 2px 0px #fff;
            z-index: 5;
            flex-wrap: wrap;
            gap: 5px;
        }

        .hud > div {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .boss-hud {
            flex-direction: row;
            justify-content: space-around;
            align-items: center;
        }

        @media (max-width: 768px) {
            .hud {
                font-size: clamp(0.6rem, 2.5vw, 1rem);
                padding: 0 5px;
                top: 5px;
            }

            .boss-hud {
                font-size: clamp(0.5rem, 2vw, 0.8rem);
                gap: 2px;
            }

            .boss-hud > div {
                max-width: 30%;
            }
        }

        /* Animations */
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        .floating { animation: float 3s ease-in-out infinite; }

        @keyframes warningFlash {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }
            20%, 40%, 60%, 80% { transform: translateX(10px); }
        }

        .warning-text {
            animation: warningFlash 0.5s ease-in-out infinite;
            font-size: clamp(3rem, 12vw, 6rem);
            color: #FF0000;
            text-shadow: 0 0 20px #FF0000, 0 0 40px #FF0000;
            font-weight: bold;
            padding: 0 10px;
            text-align: center;
        }

        .shake-screen {
            animation: shake 0.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .boss-attack-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(2rem, 8vw, 4rem);
            color: #FF0000;
            text-shadow: 0 0 20px #FF0000;
            font-weight: bold;
            animation: pulse 0.3s ease-in-out infinite;
            z-index: 15;
            pointer-events: none;
            padding: 0 10px;
            text-align: center;
            max-width: 90vw;
        }

        .dodge-button-container {
            position: fixed;
            bottom: 20vh;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
        }

        .dodge-btn {
            font-size: clamp(1.2rem, 4vw, 2rem);
            padding: clamp(10px, 2.5vw, 20px) clamp(30px, 8vw, 60px);
            animation: pulse 0.3s ease-in-out infinite;
            white-space: nowrap;
        }

        @media (max-width: 768px) {
            .dodge-button-container {
                bottom: 25vh;
            }

            .dodge-btn {
                font-size: clamp(1rem, 3.5vw, 1.5rem);
                padding: clamp(8px, 2vw, 15px) clamp(25px, 6vw, 50px);
            }
        }

        @media (max-width: 480px) {
            .dodge-button-container {
                bottom: 30vh;
            }

            .dodge-btn {
                font-size: clamp(0.9rem, 3vw, 1.2rem);
                padding: 8px 25px;
            }

            .retro-box {
                padding: 8px;
                max-width: 95%;
            }
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>

<div class="game-container">
    <!-- Canvas Layer -->
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud" class="hud hidden">
        <div>ÊÆã„ÇäÊôÇÈñì: <span id="timer">60</span>Áßí</div>
        <div>ÂæóÁÇπ: <span id="score">0</span>Áöø</div>
    </div>

    <!-- Boss HUD -->
    <div id="bossHud" class="hud boss-hud hidden">
        <div>ÊôÇÈñì: <span id="bossTimer">45</span>Áßí</div>
        <div>„Éú„ÇπHP: <span id="bossHP">50</span>/50</div>
        <div>HP: <span id="playerHP">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
    </div>

    <!-- Dodge Button -->
    <div id="dodgeButton" class="hidden dodge-button-container">
        <button class="btn interactive dodge-btn" onclick="attemptDodge()">
            ÂõûÈÅøÔºÅ
        </button>
    </div>

    <!-- Warning Screen -->
    <div id="warningScreen" class="ui-layer interactive hidden" style="background: rgba(0,0,0,0.8);">
        <div class="warning-text shake-screen">WARNING!</div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="ui-layer interactive">
        <div class="retro-box floating">
            <h1 class="text-4xl mb-2">ü•ü È§ÉÂ≠êÊäï„ÅíÊ§úÂÆö ü•ü</h1>
            <p class="text-lg mb-4">„ÄúÁõÆÊåá„Åõ„ÄÅÈ§ÉÂ≠êÂêç‰∫∫„Äú</p>
            <p class="text-sm mb-6">Âãï„ÅèÂ∫óÂì°„Åï„Çì„Å´È§ÉÂ≠ê„ÇíÊäï„Åí„Å§„Åë„ÇçÔºÅ<br>„ÇØ„É™„ÉÉ„ÇØ/„Çø„ÉÉ„Éó„ÅßÁô∫Â∞Ñ</p>
            <button class="btn" onclick="startGame()">Ë©¶È®ìÈñãÂßã</button>
        </div>
    </div>

    <!-- Result Screen -->
    <div id="resultScreen" class="ui-layer interactive hidden">
        <div class="retro-box">
            <h2 class="text-3xl mb-2">Ë©¶È®ìÁµÇ‰∫ÜÔºÅ</h2>
            <p class="text-xl mb-2">„ÅÇ„Å™„Åü„ÅÆ„Çπ„Ç≥„Ç¢</p>
            <p class="text-5xl font-bold mb-4 text-yellow-300"><span id="finalScore">0</span> Áöø</p>

            <div class="bg-white text-red-800 p-4 rounded mb-4">
                <p class="text-sm">Ë™çÂÆöÊÆµ‰Ωç</p>
                <h3 class="text-4xl font-bold" id="rankTitle">Ë¶ãÁøí„ÅÑ</h3>
                <p class="text-xs mt-2 text-gray-500" id="rankDesc">„Åæ„Å†„Åæ„Å†‰øÆË°å„ÅåË∂≥„Çä„Å™„ÅÑ„Çà„ÅÜ„Å†...</p>
            </div>

            <button class="btn" onclick="resetGame()">ÂÜçÊåëÊà¶</button>
        </div>
    </div>

    <!-- Game Over Screen (Boss Battle Failed) -->
    <div id="gameOverScreen" class="ui-layer interactive hidden">
        <div class="retro-box">
            <h2 class="text-5xl mb-4" style="color: #FF0000;">üí• GAME OVER üí•</h2>
            <p class="text-2xl mb-4">ÊôÇÈñìÂàá„ÇåÔºÅÁîªÈù¢„ÅåÁàÜÁô∫„Åó„ÅüÔºÅ</p>
            <p class="text-xl mb-2">Âà∞ÈÅî„Çπ„Ç≥„Ç¢: <span id="gameOverScore">0</span> Áöø</p>
            <button class="btn" onclick="resetGame()">ÂÜçÊåëÊà¶</button>
        </div>
    </div>

    <!-- Boss Victory Screen -->
    <div id="bossVictoryScreen" class="ui-layer interactive hidden">
        <div class="retro-box">
            <h2 class="text-5xl mb-4" style="color: #FFD700;">üèÜ „Éú„ÇπÊíÉÁ†¥ÔºÅ üèÜ</h2>
            <p class="text-2xl mb-4">Ë¶ã‰∫ã„ÄÅË¨é„ÅÆÂ≠òÂú®„ÇíÂÄí„Åó„ÅüÔºÅ</p>
            <p class="text-xl mb-2">ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: <span id="victoryScore">0</span> Áöø</p>
            <p class="text-3xl font-bold mb-4 text-yellow-300">„ÅÇ„Å™„Åü„ÅØÁúü„ÅÆÈ§ÉÂ≠ê„Éû„Çπ„Çø„Éº„Å†ÔºÅ</p>
            <button class="btn" onclick="resetGame()">ÂÜçÊåëÊà¶</button>
        </div>
    </div>
</div>

<script>
    /**
     * Game Logic
     */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Game State
    let gameState = 'START'; // START, PLAYING, WARNING, BOSS_BATTLE, END
    let score = 0;
    let timeLeft = 60;
    let lastTime = 0;
    let gameLoopId;
    let difficultyMultiplier = 1;
    let bossHP = 50;
    let bossTimeLeft = 45;
    let warningTimer = 0;
    let boss = null;
    let bossImage = new Image();
    bossImage.src = 'unknown.png';
    let playerHP = 3;
    let bossAttack = null;
    let dodgeWindow = null;

    // Assets (Using Emojis)
    const PLAYER_EMOJI = 'ü§µ'; // The Gyoza Thrower
    const STAFF_EMOJIS = ['üë®‚Äçüç≥', 'üë©‚Äçüç≥', 'üíÅ', 'üíÅ‚Äç‚ôÇÔ∏è'];
    const GYOZA_EMOJI = 'ü•ü';
    const HIT_EMOJIS = ['üòã', '‚ù§Ô∏è', 'üëç', '‚ú®'];
    const BOSS_PHRASES = [
        '„Éë„É≥„Éë„É≥„ÇØ„É≠„Éº„É´',
        'Ê≠ª„Çì„Å†„Çì„Åò„ÇÉ„Å™„ÅÑ„ÅÆ„ÄúÔºü',
        '„Ç´„É¨„ÉºÂë≥„ÅÆ„É≠„ÉÉ„Ç´„Éº',
        '„Åù„Çå„Ç™„É≥„Çª„Éº',
        '„Éç„ÇÆ„É´„Åó„Å™„ÅÑ„Åß',
        '„ÅÇ„Å®„Åß„Åã„ÅÑ„ÅÆ„ÅØËÖπ„Åã'
    ];

    // Entities
    let projectiles = [];
    let targets = [];
    let particles = [];
    let player = { x: 0, y: 0, size: 60 };
    let bossDialogue = null;

    // Audio System
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    function playSound(type) {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        switch(type) {
            case 'throw':
                oscillator.frequency.value = 400;
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
                break;
            case 'hit':
                oscillator.frequency.value = 600;
                oscillator.type = 'square';
                gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.15);
                break;
            case 'bossHit':
                oscillator.frequency.value = 200;
                oscillator.type = 'sawtooth';
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
                break;
            case 'warning':
                oscillator.frequency.value = 150;
                oscillator.type = 'triangle';
                gainNode.gain.setValueAtTime(0.25, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
                break;
            case 'explosion':
                const noise = audioContext.createBufferSource();
                const bufferSize = audioContext.sampleRate * 1;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                noise.buffer = buffer;
                noise.connect(gainNode);
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1);
                noise.start(audioContext.currentTime);
                noise.stop(audioContext.currentTime + 1);
                return;
            case 'victory':
                // Victory jingle
                [523, 587, 659, 784].forEach((freq, i) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.frequency.value = freq;
                    osc.type = 'sine';
                    gain.gain.setValueAtTime(0.1, audioContext.currentTime + i * 0.15);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + i * 0.15 + 0.3);
                    osc.start(audioContext.currentTime + i * 0.15);
                    osc.stop(audioContext.currentTime + i * 0.15 + 0.3);
                });
                return;
        }
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        player.x = canvas.width / 2;
        player.y = canvas.height - 80;
    }
    window.addEventListener('resize', resize);
    resize();

    // Input Handling
    canvas.addEventListener('pointerdown', (e) => {
        if (gameState !== 'PLAYING' && gameState !== 'BOSS_BATTLE') return;

        // Don't throw gyoza during dodge window
        if (bossAttack && bossAttack.currentTime >= bossAttack.chargeTime) return;

        const rect = canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;

        throwGyoza(clickX, clickY);
    });

    function throwGyoza(targetX, targetY) {
        const angle = Math.atan2(targetY - player.y, targetX - player.x);
        const speed = 15;

        projectiles.push({
            x: player.x,
            y: player.y - 20,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            rotation: 0,
            active: true
        });

        playSound('throw');
    }

    class Target {
        constructor() {
            this.reset();
            // Initial random position to prevent all appearing at same spot
            this.x = Math.random() * (canvas.width - 100) + 50;
            this.y = Math.random() * (canvas.height / 2) + 50;
        }

        reset() {
            this.emoji = STAFF_EMOJIS[Math.floor(Math.random() * STAFF_EMOJIS.length)];
            this.size = 50;
            this.x = Math.random() * (canvas.width - 100) + 50;
            this.y = -100; // Start above screen
            // Random movement patterns
            this.vx = (Math.random() - 0.5) * 4 * difficultyMultiplier;
            this.vy = (Math.random() * 2 + 1) * difficultyMultiplier; 
            this.state = 'active'; // active, hit
            this.hitTimer = 0;
            this.changeDirTimer = 0;
        }

        update() {
            if (this.state === 'hit') {
                this.hitTimer--;
                if (this.hitTimer <= 0) this.reset();
                return;
            }

            this.x += this.vx;
            this.y += this.vy;

            // Change direction randomly
            this.changeDirTimer++;
            if (this.changeDirTimer > 60) {
                this.vx = (Math.random() - 0.5) * 4 * difficultyMultiplier;
                this.changeDirTimer = 0;
            }

            // Bounce off walls
            if (this.x < 30 || this.x > canvas.width - 30) this.vx *= -1;

            // Reset if goes below screen
            if (this.y > canvas.height + 50) {
                this.reset();
            }
        }

        draw() {
            ctx.font = `${this.size}px serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            if (this.state === 'hit') {
                ctx.globalAlpha = this.hitTimer / 20;
                ctx.fillText('üòã', this.x, this.y);
                ctx.globalAlpha = 1.0;
            } else {
                // Flip sprite based on direction
                ctx.save();
                ctx.translate(this.x, this.y);
                if (this.vx < 0) ctx.scale(-1, 1);
                ctx.fillText(this.emoji, 0, 0);
                ctx.restore();
            }
        }
    }

    class Particle {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 10;
            this.vy = (Math.random() - 0.5) * 10;
            this.life = 30;
            this.text = HIT_EMOJIS[Math.floor(Math.random() * HIT_EMOJIS.length)];
            this.size = Math.random() * 20 + 10;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life--;
        }
        draw() {
            ctx.globalAlpha = this.life / 30;
            ctx.font = `${this.size}px serif`;
            ctx.fillText(this.text, this.x, this.y);
            ctx.globalAlpha = 1.0;
        }
    }

    class Boss {
        constructor() {
            this.x = canvas.width / 2;
            this.y = canvas.height / 3;
            this.size = 150;
            this.hp = 50;
            this.maxHP = 50;
            this.vx = 3;
            this.vy = 2;
            this.hitFlash = 0;
            this.attackTimer = 0;
            this.attackInterval = 200; // Attack every 3.3 seconds (at 60fps)
            this.chargeScale = 1;
        }

        update() {
            // Move boss in a pattern (slower during charge)
            const speedMult = bossAttack && bossAttack.currentTime < bossAttack.chargeTime ? 0.3 : 1;
            this.x += this.vx * speedMult;
            this.y += this.vy * speedMult;

            // Bounce off walls
            if (this.x < this.size/2 || this.x > canvas.width - this.size/2) {
                this.vx *= -1;
            }
            if (this.y < this.size/2 || this.y > canvas.height/2) {
                this.vy *= -1;
            }

            if (this.hitFlash > 0) this.hitFlash--;

            // Attack timer
            this.attackTimer++;
            if (this.attackTimer >= this.attackInterval) {
                this.attack();
                this.attackTimer = 0;
            }

            // Charge animation
            if (bossAttack && bossAttack.currentTime < bossAttack.chargeTime) {
                const chargeProgress = bossAttack.currentTime / bossAttack.chargeTime;
                this.chargeScale = 1 + Math.sin(chargeProgress * Math.PI * 4) * 0.2 * chargeProgress;
            } else {
                this.chargeScale = 1;
            }
        }

        attack() {
            // Create attack with charge phase
            bossAttack = {
                chargeTime: 90, // 1.5 second charge
                dodgeWindowStart: 90,
                dodgeWindowEnd: 150, // 1 second dodge window
                totalTime: 180,
                currentTime: 0,
                dodged: false,
                text: BOSS_PHRASES[Math.floor(Math.random() * BOSS_PHRASES.length)]
            };
            playSound('warning');
        }

        draw() {
            // Draw HP bar (responsive size)
            const barWidth = Math.min(canvas.width * 0.6, 300);
            const barHeight = Math.min(canvas.height * 0.03, 20);
            const barX = canvas.width / 2 - barWidth / 2;
            const barY = Math.min(canvas.height * 0.08, 50);

            ctx.fillStyle = '#333';
            ctx.fillRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            ctx.fillStyle = '#00FF00';
            ctx.fillRect(barX, barY, barWidth * (this.hp / this.maxHP), barHeight);

            // Draw boss image with charge effect
            if (bossImage.complete) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.chargeScale, this.chargeScale);

                // Flash red during charge
                if (bossAttack && bossAttack.currentTime < bossAttack.chargeTime) {
                    ctx.filter = `hue-rotate(${Math.sin(bossAttack.currentTime * 0.3) * 180}deg) brightness(1.5)`;
                }

                if (this.hitFlash > 0) {
                    ctx.globalAlpha = 0.5;
                }

                ctx.drawImage(bossImage, -this.size/2, -this.size/2, this.size, this.size);
                ctx.restore();
            }
        }

        hit() {
            this.hp--;
            this.hitFlash = 5;

            // Show random boss phrase
            const phrase = BOSS_PHRASES[Math.floor(Math.random() * BOSS_PHRASES.length)];
            bossDialogue = {
                text: phrase,
                x: this.x,
                y: this.y - this.size / 2 - 30,
                life: 60,
                update() {
                    this.y -= 1;
                    this.life--;
                },
                draw() {
                    ctx.save();
                    ctx.globalAlpha = Math.min(1, this.life / 20);
                    const fontSize = Math.min(canvas.width / 25, 24);
                    ctx.font = `bold ${fontSize}px serif`;
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#FFFFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = Math.max(2, fontSize / 6);
                    const maxWidth = canvas.width * 0.8;
                    ctx.strokeText(this.text, this.x, this.y, maxWidth);
                    ctx.fillText(this.text, this.x, this.y, maxWidth);
                    ctx.restore();
                }
            };

            return this.hp <= 0;
        }
    }

    function startGame() {
        gameState = 'PLAYING';
        score = 0;
        timeLeft = 60;
        difficultyMultiplier = 1;
        projectiles = [];
        particles = [];
        targets = [];
        bossHP = 50;
        bossTimeLeft = 45;
        warningTimer = 0;
        boss = null;
        playerHP = 3;
        bossAttack = null;

        // Create initial targets
        for(let i=0; i<3; i++) targets.push(new Target());

        document.getElementById('startScreen').classList.add('hidden');
        document.getElementById('resultScreen').classList.add('hidden');
        document.getElementById('gameOverScreen').classList.add('hidden');
        document.getElementById('bossVictoryScreen').classList.add('hidden');
        document.getElementById('warningScreen').classList.add('hidden');
        document.getElementById('dodgeButton').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        document.getElementById('bossHud').classList.add('hidden');

        updateHUD();
        lastTime = performance.now();
        gameLoopId = requestAnimationFrame(gameLoop);
    }

    function resetGame() {
        document.getElementById('resultScreen').classList.add('hidden');
        document.getElementById('gameOverScreen').classList.add('hidden');
        document.getElementById('bossVictoryScreen').classList.add('hidden');
        document.getElementById('warningScreen').classList.add('hidden');
        document.getElementById('dodgeButton').classList.add('hidden');
        document.getElementById('startScreen').classList.remove('hidden');
        document.getElementById('hud').classList.add('hidden');
        document.getElementById('bossHud').classList.add('hidden');

        // Quick render of background
        ctx.fillStyle = '#fdfbf7'; // Clear canvas
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function endGame() {
        gameState = 'END';
        cancelAnimationFrame(gameLoopId);
        
        // Calculate Rank
        const rank = calculateRank(score);
        
        document.getElementById('finalScore').innerText = score;
        document.getElementById('rankTitle').innerText = rank.title;
        document.getElementById('rankDesc').innerText = rank.desc;
        
        document.getElementById('hud').classList.add('hidden');
        document.getElementById('resultScreen').classList.remove('hidden');
    }

    function calculateRank(s) {
        if (s < 10) return { title: "5Á¥öÔºöÁöøÊ¥ó„ÅÑË¶ãÁøí„ÅÑ", desc: "„Åæ„Åö„ÅØÁöøÊ¥ó„ÅÑ„Åã„ÇâÂßã„ÇÅ„Åæ„Åó„Çá„ÅÜ„ÄÇ" };
        if (s < 20) return { title: "4Á¥öÔºöÈ§ÉÂ≠êÂåÖ„Åø‰øÇ", desc: "ÁöÆ„ÇíÁ†¥„Åã„Å™„ÅÑ„Çà„ÅÜ„Å´„Å≠„ÄÇ" };
        if (s < 40) return { title: "3Á¥öÔºöÁÑº„ÅçÂ†¥ÊãÖÂΩì", desc: "„Éë„É™„ÉÉ„Å®ÁÑº„Åë„Çã„Çà„ÅÜ„Å´„Å™„Å£„Å¶„Åç„ÅüÔºÅ" };
        if (s < 60) return { title: "2Á¥öÔºö„Éï„É≠„Ç¢„ÉÅ„Éº„Éï", desc: "„ÅäÂÆ¢Êßò„Å∏„ÅÆÊèê‰æõ„Çπ„Éî„Éº„Éâ„ÅåÂëΩ„ÄÇ" };
        if (s < 80) return { title: "1Á¥öÔºöÂ∫óÈï∑", desc: "„Åì„ÅÆÂ∫ó„ÅØÂêõ„Å´‰ªª„Åõ„ÅüÔºÅ" };
        if (s < 100) return { title: "ÂàùÊÆµÔºöÈ§ÉÂ≠êÁéã", desc: "Ë°ó„Åß‰∏ÄÁï™„ÅÆÈ§ÉÂ≠êÊäï„Åí„ÄÇ" };
        if (s < 130) return { title: "Â∏´ÁØÑ‰ª£", desc: "„ÇÇ„ÅØ„ÇÑÊäï„Åí„ÇãÂßø„ÅåË¶ã„Åà„Å™„ÅÑ„ÄÇ" };
        return { title: "ÂÖçË®±ÁöÜ‰ºùÔºöÈ§ÉÂ≠êÁ•û", desc: "È§ÉÂ≠ê„Å®‰∏Ä‰ΩìÂåñ„Åó„ÅüÂ≠òÂú®„ÄÇ" };
    }

    function updateHUD() {
        document.getElementById('score').innerText = score;
        document.getElementById('timer').innerText = Math.ceil(timeLeft);
        if (boss) {
            document.getElementById('bossHP').innerText = boss.hp;
            document.getElementById('bossTimer').innerText = Math.ceil(bossTimeLeft);
            const hearts = '‚ù§Ô∏è'.repeat(playerHP) + 'üñ§'.repeat(3 - playerHP);
            document.getElementById('playerHP').innerText = hearts;
        }
    }

    function attemptDodge() {
        if (!bossAttack) return;

        const currentTime = bossAttack.currentTime;
        const isInWindow = currentTime >= bossAttack.dodgeWindowStart && currentTime <= bossAttack.dodgeWindowEnd;

        if (isInWindow) {
            // Successful dodge!
            bossAttack.dodged = true;
            document.getElementById('dodgeButton').classList.add('hidden');
            playSound('hit'); // Success sound

            // Visual feedback
            for(let i=0; i<10; i++) {
                particles.push({
                    x: canvas.width / 2,
                    y: canvas.height - 100,
                    vx: (Math.random() - 0.5) * 15,
                    vy: -Math.random() * 10,
                    life: 30,
                    text: '‚ú®',
                    size: Math.random() * 30 + 20,
                    update() {
                        this.x += this.vx;
                        this.y += this.vy;
                        this.life--;
                    },
                    draw() {
                        ctx.globalAlpha = this.life / 30;
                        ctx.font = `${this.size}px serif`;
                        ctx.fillText(this.text, this.x, this.y);
                        ctx.globalAlpha = 1.0;
                    }
                });
            }
        } else {
            // Failed - too early or too late
            playSound('explosion');
        }
    }

    function gameLoop(timestamp) {
        if (gameState !== 'PLAYING' && gameState !== 'WARNING' && gameState !== 'BOSS_BATTLE') return;

        const deltaTime = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        // Check if we need to trigger boss battle
        if (gameState === 'PLAYING' && score >= 50) {
            gameState = 'WARNING';
            warningTimer = 3; // 3 seconds warning
            document.getElementById('warningScreen').classList.remove('hidden');
            playSound('warning');
            lastTime = timestamp;
            requestAnimationFrame(gameLoop);
            return;
        }

        // WARNING state
        if (gameState === 'WARNING') {
            warningTimer -= deltaTime;
            if (warningTimer <= 0) {
                gameState = 'BOSS_BATTLE';
                boss = new Boss();
                bossTimeLeft = 30;
                targets = []; // Clear normal targets
                projectiles = [];
                document.getElementById('warningScreen').classList.add('hidden');
                document.getElementById('hud').classList.add('hidden');
                document.getElementById('bossHud').classList.remove('hidden');
            }
            requestAnimationFrame(gameLoop);
            return;
        }

        // BOSS_BATTLE state
        if (gameState === 'BOSS_BATTLE') {
            bossTimeLeft -= deltaTime;
            if (bossTimeLeft <= 0) {
                // Time's up! Game Over with explosion
                gameState = 'GAME_OVER';
                cancelAnimationFrame(gameLoopId);
                showExplosionAndGameOver();
                return;
            }

            // Handle boss attack
            if (bossAttack) {
                bossAttack.currentTime++;

                // Show dodge button during dodge window
                if (bossAttack.currentTime >= bossAttack.dodgeWindowStart &&
                    bossAttack.currentTime <= bossAttack.dodgeWindowEnd &&
                    !bossAttack.dodged) {
                    document.getElementById('dodgeButton').classList.remove('hidden');
                } else {
                    document.getElementById('dodgeButton').classList.add('hidden');
                }

                // Attack hits if not dodged
                if (bossAttack.currentTime >= bossAttack.totalTime) {
                    if (!bossAttack.dodged) {
                        // Player took damage
                        playerHP--;
                        playSound('explosion');

                        // Screen shake effect
                        for(let i=0; i<20; i++) {
                            particles.push({
                                x: player.x + (Math.random() - 0.5) * 100,
                                y: player.y + (Math.random() - 0.5) * 100,
                                vx: (Math.random() - 0.5) * 20,
                                vy: (Math.random() - 0.5) * 20,
                                life: 30,
                                text: 'üí•',
                                size: Math.random() * 40 + 20,
                                update() {
                                    this.x += this.vx;
                                    this.y += this.vy;
                                    this.life--;
                                },
                                draw() {
                                    ctx.globalAlpha = this.life / 30;
                                    ctx.font = `${this.size}px serif`;
                                    ctx.fillText(this.text, this.x, this.y);
                                    ctx.globalAlpha = 1.0;
                                }
                            });
                        }

                        if (playerHP <= 0) {
                            // Player died
                            gameState = 'GAME_OVER';
                            cancelAnimationFrame(gameLoopId);
                            showExplosionAndGameOver();
                            return;
                        }
                    }
                    bossAttack = null;
                }
            }

            updateHUD();
        } else {
            // PLAYING state
            // Timer Logic
            timeLeft -= deltaTime;
            if (timeLeft <= 0) {
                timeLeft = 0;
                endGame();
                return;
            }

            // Increase difficulty over time (targets move faster, more targets appear)
            difficultyMultiplier = 1 + (60 - timeLeft) / 30; // 1.0 -> 3.0 speed
            if (targets.length < 3 + Math.floor((60 - timeLeft) / 15)) {
                targets.push(new Target());
            }

            updateHUD();
        }

        // Clear Canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw Player
        ctx.font = "60px serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        ctx.fillText(PLAYER_EMOJI, player.x, player.y);

        // Update & Draw Projectiles
        for (let i = projectiles.length - 1; i >= 0; i--) {
            let p = projectiles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.rotation += 0.2;

            // Draw Gyoza
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation);
            ctx.font = "30px serif";
            ctx.textBaseline = "middle";
            ctx.fillText(GYOZA_EMOJI, 0, 0);
            ctx.restore();

            // Remove if out of bounds
            if (p.x < -50 || p.x > canvas.width + 50 || p.y < -50 || p.y > canvas.height + 50) {
                projectiles.splice(i, 1);
                continue;
            }

            // Collision Detection
            if (gameState === 'BOSS_BATTLE' && boss) {
                // Boss collision
                const dx = p.x - boss.x;
                const dy = p.y - boss.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < boss.size / 2) {
                    const defeated = boss.hit();
                    projectiles.splice(i, 1);
                    playSound('bossHit');

                    // Add hit effect
                    for(let k=0; k<5; k++) {
                        particles.push(new Particle(boss.x, boss.y));
                    }

                    if (defeated) {
                        // Boss defeated!
                        gameState = 'BOSS_VICTORY';
                        cancelAnimationFrame(gameLoopId);
                        showBossVictory();
                        return;
                    }
                }
            } else {
                // Normal target collision
                for (let t of targets) {
                    if (t.state === 'active') {
                        const dx = p.x - t.x;
                        const dy = p.y - t.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);

                        if (dist < 40) { // Hit!
                            t.state = 'hit';
                            t.hitTimer = 20;
                            score++;
                            projectiles.splice(i, 1);
                            playSound('hit');

                            // Add hit effect
                            for(let k=0; k<3; k++) {
                                particles.push(new Particle(t.x, t.y));
                            }
                            break; // One gyoza hits one target
                        }
                    }
                }
            }
        }

        // Update & Draw Boss or Targets
        if (gameState === 'BOSS_BATTLE' && boss) {
            boss.update();
            boss.draw();
        } else {
            // Update & Draw Targets
            targets.forEach(t => {
                t.update();
                t.draw();
            });
        }

        // Update & Draw Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.update();
            p.draw();
            if (p.life <= 0) particles.splice(i, 1);
        }

        // Update & Draw Boss Dialogue
        if (bossDialogue) {
            bossDialogue.update();
            bossDialogue.draw();
            if (bossDialogue.life <= 0) {
                bossDialogue = null;
            }
        }

        // Draw Boss Attack Warning
        if (bossAttack && gameState === 'BOSS_BATTLE') {
            // Responsive font sizes based on canvas width
            const baseFontSize = Math.min(canvas.width / 15, 52);
            const phraseFontSize = Math.min(canvas.width / 20, 36);
            const dodgeFontSize = Math.min(canvas.width / 16, 48);
            const explosionFontSize = Math.min(canvas.width / 10, 96);

            // Charge phase (boss is powering up)
            if (bossAttack.currentTime < bossAttack.chargeTime) {
                ctx.save();
                ctx.font = `bold ${baseFontSize}px serif`;
                ctx.textAlign = 'center';
                ctx.fillStyle = '#FF6600';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = Math.max(2, baseFontSize / 10);
                const alpha = Math.sin(bossAttack.currentTime * 0.3) * 0.3 + 0.7;
                ctx.globalAlpha = alpha;

                // Wrap text if needed
                const chargingText = '‚ö° „Éú„Çπ„ÅåÂäõ„Çí„Åü„ÇÅ„Å¶„ÅÑ„ÇãÔºÅ ‚ö°';
                const maxWidth = canvas.width * 0.9;
                ctx.strokeText(chargingText, canvas.width / 2, canvas.height / 2, maxWidth);
                ctx.fillText(chargingText, canvas.width / 2, canvas.height / 2, maxWidth);

                // Show boss phrase
                ctx.font = `bold ${phraseFontSize}px serif`;
                ctx.fillStyle = '#FFFF00';
                ctx.strokeText(bossAttack.text, canvas.width / 2, canvas.height / 2 + baseFontSize * 1.2, maxWidth);
                ctx.fillText(bossAttack.text, canvas.width / 2, canvas.height / 2 + baseFontSize * 1.2, maxWidth);
                ctx.restore();
            }

            // Dodge window indicator
            if (bossAttack.currentTime >= bossAttack.dodgeWindowStart &&
                bossAttack.currentTime <= bossAttack.dodgeWindowEnd) {
                ctx.save();
                ctx.font = `bold ${dodgeFontSize}px serif`;
                ctx.textAlign = 'center';
                ctx.fillStyle = '#00FF00';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = Math.max(2, dodgeFontSize / 10);
                const pulse = Math.sin(bossAttack.currentTime * 0.5) * 0.2 + 1;
                ctx.scale(pulse, pulse);

                const dodgeText = '‰ªä„Å†ÔºÅÂõûÈÅø„Éú„Çø„É≥„ÇíÊäº„ÅõÔºÅ';
                const maxWidth = canvas.width * 0.9 / pulse;
                ctx.strokeText(dodgeText, canvas.width / 2 / pulse, canvas.height / 2 / pulse + 100, maxWidth);
                ctx.fillText(dodgeText, canvas.width / 2 / pulse, canvas.height / 2 / pulse + 100, maxWidth);
                ctx.restore();
            }

            // Attack execution phase
            if (bossAttack.currentTime > bossAttack.dodgeWindowEnd && !bossAttack.dodged) {
                ctx.save();
                ctx.font = `bold ${explosionFontSize}px serif`;
                ctx.textAlign = 'center';
                ctx.fillStyle = '#FF0000';
                ctx.globalAlpha = 0.9;
                const shake = Math.sin(bossAttack.currentTime * 2) * 10;
                ctx.fillText('üí•', canvas.width / 2 + shake, canvas.height / 2);
                ctx.restore();
            }
        }

        requestAnimationFrame(gameLoop);
    }

    function showExplosionAndGameOver() {
        playSound('explosion');

        // Create explosion effect
        particles = [];
        for (let i = 0; i < 50; i++) {
            particles.push({
                x: canvas.width / 2,
                y: canvas.height / 2,
                vx: (Math.random() - 0.5) * 30,
                vy: (Math.random() - 0.5) * 30,
                life: 60,
                text: 'üí•',
                size: Math.random() * 40 + 20,
                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.life--;
                },
                draw() {
                    ctx.globalAlpha = this.life / 60;
                    ctx.font = `${this.size}px serif`;
                    ctx.fillText(this.text, this.x, this.y);
                    ctx.globalAlpha = 1.0;
                }
            });
        }

        // Animate explosion
        let explosionFrames = 60;
        const explosionLoop = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#FF0000';
            ctx.globalAlpha = 0.3 * (explosionFrames / 60);
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalAlpha = 1.0;

            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }

            explosionFrames--;
            if (explosionFrames > 0) {
                requestAnimationFrame(explosionLoop);
            } else {
                document.getElementById('gameOverScore').innerText = score;
                document.getElementById('bossHud').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }
        };
        explosionLoop();
    }

    function showBossVictory() {
        playSound('victory');
        document.getElementById('victoryScore').innerText = score;
        document.getElementById('bossHud').classList.add('hidden');
        document.getElementById('bossVictoryScreen').classList.remove('hidden');
    }

    // Initial Draw
    ctx.fillStyle = '#fdfbf7';
    ctx.font = "30px serif";
    ctx.textAlign = "center";
    ctx.fillText("Loading...", canvas.width/2, canvas.height/2);

</script>
</body>
</html>